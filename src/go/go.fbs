namespace go;


// Represents all compiler opcodes generated from node types in Opticode.
enum Opcode : uint {
  // --- Declarations ---
  Package = 0,        // package <identifier> | Type1
  Import = 1,         // import "<path>" | Type1
  ImportValue,        // <name> "<url>"   | Type2
  Const,              // const <name> = <expr> | Type1
  ConstValue,         // <name> = <expr> | Type2
  Var,                // var <name> = <expr> | Type1
  VarValue,           // <name> = <expr> | Type2
  Type,               // type <name> <type> | Type2
  Func,               // func <name>(...) { ... } | Type1

  // --- Control Flow ---
  If,                 // if <cond> { ... } | Type1
  For,                // for <forRange> { ... } | Type1
  ForRange,           // <init>; <cond>; <post> | Type1
  Range,              // for <key>, <val> := range <expr> | Type1
  Switch,             // switch <expr> { ... } | Type1
  Select,             // select { ... } | Type1
  Case,               // case <expr>: <...> | Type1
  Default,            // default: <...> | Type1

  // --- Operators ---
  Add,                // <a> + <b> | Type2
  Sub,                // <a> - <b> | Type2
  Mul,                // <a> * <b> | Type2
  Div,                // <a> / <b> | Type2
  Mod,                // <a> % <b> | Type2
  Inc,                // <a>++ | Type3
  Dec,                // <a>-- | Type3
  Assign,             // <a> = <b> | Type2
  AddAssign,          // <a> += <b> | Type2
  SubAssign,          // <a> -= <b> | Type2
  MulAssign,          // <a> *= <b> | Type2
  DivAssign,          // <a> += <b> | Type2
  ModAssign,          // <a> %= <b> | Type2
  BitAndAssign,       // <a> &= <b> | Type2
  BitOrAssign,        // <a> |= <b> | Type2
  BitXorAssign,       // <a> ^= <b> | Type2
  BitClearAssign,     // <a> &^= <b> | Type2
  LeftShiftAssign,    // <a> <<= <b> | Type2
  RightShiftAssign,   // <a> >>= <b> | Type2
  Equal,              // <a> == <b> | Type2
  NotEqual,           // <a> != <b> | Type2
  Less,               // <a> < <b> | Type2
  LessEqual,          // <a> <= <b> | Type2
  Greater,            // <a> > <b> | Type2
  GreaterEqual,       // <a> >= <b> | Type2
  And,                // <a> && <b> | Type2
  Or,                 // <a> || <b> | Type2
  Not,                // !<a> | Type3
  BitAnd,             // <a> & <b> | Type2
  BitOr,              // <a> | <b> | Type2
  BitXor,             // <a> ^ <b> | Type2
  BitClear,           // <a> ^& <b> | Type2
  LeftShift,          // <a> << <b> | Type2
  RightShift,         // <a> >> <b> | Type2

  // --- Channels ---
  Send,               // ch <- val | Type2
  Receive,            // <-ch | Type3

  // --- Pointers & References ---
  AddrOf,             // &var | Type3
  Deref,              // *ptr | Type3

  // --- Functions & Calls ---
  Call,               // func(...) | Type1
  Return,             // return <expr> | Type3
  Defer,              // defer <call> | Type3
  GoRoutine,          // go <call> | Type3

  // --- Composite Types ---
  Map,                // map[keyType]valType{...} | Type1
  Array,              // [n]type{...} | Type1
  Chan,               // chan type | Type3

  // --- Error Handling ---
  Panic,              // panic(<expr>) | Type3
  Recover,            // recover() | NONE

  // --- Built-in & Special ---
  Make,               // make(...) | Type1
  New,                // new(type) | Type3
  Len,                // len(...) | Type1
  Cap,                // cap(...) | Type1
  Append,             // append(...) | Type1
  Copy,               // copy(dst, src) | Type2
  Close,              // close(ch) | Type3
  Complex,            // complex(...) | Type1
  Real,               // real(...) | Type1
  Imag,               // imag(...) | Type1
  Print,              // print(...) | Type1
  Println             // println(...) | Type1
}

enum Flag : uint {
  None = 0,
  NodeType1 = 1,
  NodeType2 = 2,
  NodeType3 = 4,
}

enum ValueFlag : uint {
  None = 0,
  Pointer = 1,
}

table NodeValue {
  type:uint;
  value:long; // look up table for value
  flags:ValueFlag;
}

union NodeUnion {
  Type1, // If node contains array or requires id
  Type2, // If node only requires 2 node values and no id
  Type3, // If node only required 1 node value and no id
}

table Type1 {
  id:uint; // Should be an int to go into a reference table
  fields:[NodeValue];
}

table Type2 {
  left:NodeValue;
  right:NodeValue;
}

table Type3 {
  value:NodeValue; // Any flags stored outside of the node content
}
 
table Node {
  id:long;             // unique node id
  opcode:Opcode;       // opcode of node
  parent:long;         // parent node id
  next:long;           // next sibling id
  flags:Flag;          // contains the node type and miscellanous flags     
  node:NodeUnion;      // actual node contents
}

table Program {
  nodes:[Node]; // flat array of all nodes
  name:string;
  schver:string; // Schema version
  wailsver:string; // Version of wails
  version:string; // Version of the program
  flags:uint; // I don't know what I would use this for yet
}

root_type Program;
